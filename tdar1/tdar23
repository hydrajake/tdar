#!/bin/bash
# tdar
# Version 4.0
# Updated 11/14/2025
# Totals numeric or time-based fields by date, with ranges
# Usage: tdar [-s] [-p] <file_name> [field_name|all] [{start_date:end_date}]
# Written by J.Mock and M.Seifert

# -----------------------------
# Flags
# -----------------------------
skipmode=false
printmode=false

while [[ "$1" == -* ]]; do
    case "$1" in
        -s) skipmode=true ;;
        -p) printmode=true ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
    shift
done

# -----------------------------
# Required argument: JSON file
# -----------------------------
json_file="$1"
if [[ -z "$json_file" ]]; then
    echo "Error: No JSON file specified."
    exit 1
fi
shift

if ! [[ -f "$json_file" ]]; then
    echo "Error: File '$json_file' not found."
    exit 1
fi

# -----------------------------
# Detect field and date/range
# -----------------------------
fieldname="$1"
daterange="$2"

normalize_date() {
    local d="$1"
    d="${d//./-}"
    d="${d//\//-}"
    if [[ "$d" =~ ^[0-9]{2}-[0-9]{2}-[0-9]{4}$ ]]; then
        echo "$d"
    else
        echo ""
    fi
}

# -----------------------------
# Built-in fields
# -----------------------------
numeric_fields=(
    "TotalSales"
    "ActualPunchedDollars"
    "ActualTransactions"
    "ProjectedTransactions"
    "ActualSandwichCount"
    "ProjectedSandwichCount"
    "CrewActualPunchedDollars"
)

time_fields=(
    "ActualPunchedHours"
    "SalariedManagerScheduledHours"
    "TotalScheduleHours"
    "TotalNeededHours"
    "CrewLaborHours"
    "VLHScheduledHours"
    "FixedScheduledHours"
    "FloorMgmtScheduledHours"
    "UnassignedVLHScheduleHours"
    "UnassignedFixedScheduleHours"
    "UnassignedFloorMgmtScheduleHours"
    "VLHNeededHours"
    "FloorMgmtNeededHours"
)

# Determine fields to process
if [[ "$fieldname" == "all" || -z "$fieldname" ]]; then
    fields_to_process=("${numeric_fields[@]}" "${time_fields[@]}")
else
    fields_to_process=("$fieldname")
fi

# -----------------------------
# Generate date list
# -----------------------------
target_dates=()

if [[ "$daterange" =~ ^\{(.+):(.+)\}$ ]]; then
    start_date="${BASH_REMATCH[1]}"
    end_date="${BASH_REMATCH[2]}"
    # Convert to YYYY-MM-DD for date arithmetic
    start_iso=$(date -d "$start_date" +"%Y-%m-%d") || { echo "Invalid start date"; exit 1; }
    end_iso=$(date -d "$end_date" +"%Y-%m-%d") || { echo "Invalid end date"; exit 1; }

    current="$start_iso"
    while [[ "$current" < "$end_iso" || "$current" == "$end_iso" ]]; do
        target_dates+=("$(date -d "$current" +"%m-%d-%Y")")
        current=$(date -I -d "$current + 1 day") || { echo "Error generating date sequence"; exit 1; }
    done
elif [[ -n "$daterange" ]]; then
    nd=$(normalize_date "$daterange")
    [[ -n "$nd" ]] && target_dates+=("$nd")
else
    # if no date supplied, use all dates in JSON
    mapfile -t target_dates < <(jq -r '.[].Date' "$json_file")
fi

# -----------------------------
# Helpers â€” time conversion
# -----------------------------
time_to_minutes() {
    local t="$1"
    [[ -z "$t" || "$t" == "null" ]] && echo 0 && return
    local h="${t%%:*}"
    local m="${t##*:}"
    echo $((10#$h * 60 + 10#$m))
}

minutes_to_time() {
    local total="$1"
    printf "%d:%02d" $((total/60)) $((total%60))
}

# -----------------------------
# Output buffer (for -p mode)
# -----------------------------
output="Reading file...\nTotaling data...\n\n"

# -----------------------------
# Process a single date
# -----------------------------
process_date() {
    local date="$1"
    local block="---- Date: $date ----\n"

    for field in "${fields_to_process[@]}"; do
        if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
            total=$(jq -r --arg d "$date" --arg f "$field" '
                .[] | select(.Date == $d)
                | .QuarterHourEndTime
                | to_entries[]
                | .value[$f]
            ' "$json_file" | jq -s 'add // 0')
            total=$(printf "%.2f" "$total")
            block+="$field: $total\n"

        elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
            mins=0
            while IFS= read -r t; do
                mins=$((mins + $(time_to_minutes "$t")))
            done < <(jq -r --arg d "$date" --arg f "$field" '
                .[] | select(.Date == $d)
                | .QuarterHourEndTime
                | to_entries[]
                | .value[$f]
            ' "$json_file")
            block+="$field: $(minutes_to_time "$mins")\n"

        else
            block+="$field: (unknown field)\n"
        fi
    done

    block+="\n"
    echo -e "$block"
    [[ "$printmode" == true ]] && output+="$block"
}

# -----------------------------
# Grand totals for selected dates
# -----------------------------
do_grand_totals() {
    local block="==== GRAND TOTALS ====\n"

    for field in "${fields_to_process[@]}"; do
        if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
            total=0
            for d in "${target_dates[@]}"; do
                t=$(jq -r --arg d "$d" --arg f "$field" '
                    .[] | select(.Date == $d)
                    | .QuarterHourEndTime
                    | to_entries[]
                    | .value[$f]
                ' "$json_file" | jq -s 'add // 0')
                total=$(echo "$total + $t" | bc)
            done
            total=$(printf "%.2f" "$total")
            block+="$field: $total\n"

        elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
            mins=0
            for d in "${target_dates[@]}"; do
                while IFS= read -r t; do
                    mins=$((mins + $(time_to_minutes "$t")))
                done < <(jq -r --arg d "$d" --arg f "$field" '
                    .[] | select(.Date == $d)
                    | .QuarterHourEndTime
                    | to_entries[]
                    | .value[$f]
                ' "$json_file")
            done
            block+="$field: $(minutes_to_time "$mins")\n"
        fi
    done

    echo -e "$block"
    [[ "$printmode" == true ]] && output+="$block"
}

# -----------------------------
# Execute
# -----------------------------
if [[ "$skipmode" == true ]]; then
    do_grand_totals
else
    for d in "${target_dates[@]}"; do
        process_date "$d"
    done
    do_grand_totals
fi

# -----------------------------
# Print-to-file mode (-p)
# -----------------------------
# Create file
if $printmode; then
	read -p "Enter output file name: " fname
	fname+=".txt"
        if [[ -e "$fname" ]]; then
 	read -p "File exists. Overwrite? (y/n): " yn
       	[[ "$yn" != [Yy] ]] && echo "Aborting." && exit 1
fi
echo -e "$output" > "$fname"
sed -i '1,2d' "$fname"
sed -i '1i ------RESULTS----' "$fname"
echo "File created: $fname"
fi
#
exit 0
#
