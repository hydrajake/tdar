#!/bin/bash
# tdar
# Version 2.9
# Updated 11/13/2025
# Totals numeric or time-based fields by date, with break, summary, and print-to-file options
# Usage: tdar [-b | -s | -p] <file_name> [field_name] [date]
# Written by J.Mock and M.Seifert

# --- Initialize flags ---
break_mode=false
summary_mode=false
print_mode=false

# --- Parse flags ---
while [[ "$1" == -* ]]; do
    case "$1" in
        -b) break_mode=true ;;
        -s) summary_mode=true ;;
        -p) print_mode=true ;;
        *) echo "Unknown option $1"; exit 1 ;;
    esac
    shift
done

# --- Arguments ---
json_file="$1"
arg2="$2"
arg3="$3"

if [ -z "$json_file" ]; then
    echo "Usage: $0 [-b | -s | -p] <file_name> [field_name] [date]"
    exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is not installed. Please install it (e.g. sudo apt install jq)."
    exit 1
fi

# --- Helpers ---
time_to_minutes() {
    local time_str="$1"
    [[ -z "$time_str" || "$time_str" == "null" ]] && echo 0 && return
    local hours="${time_str%%:*}"
    local minutes="${time_str##*:}"
    hours=$((10#$hours))
    minutes=$((10#$minutes))
    echo $((hours * 60 + minutes))
}

minutes_to_time() {
    local total_minutes="$1"
    local hours=$((total_minutes / 60))
    local minutes=$((total_minutes % 60))
    printf "%d:%02d" "$hours" "$minutes"
}

normalize_date() {
    echo "$1" | sed 's/[./]/-/g'
}

# --- Field lists ---
numeric_fields=(
    "TotalSales"
    "ActualPunchedDollars"
    "ActualTransactions"
    "ProjectedTransactions"
    "ActualSandwichCount"
    "ProjectedSandwichCount"
    "CrewActualPunchedDollars"
)

time_fields=(
    "ActualPunchedHours"
    "SalariedManagerScheduledHours"
    "TotalScheduleHours"
    "TotalNeededHours"
    "CrewLaborHours"
    "VLHScheduledHours"
    "FixedScheduledHours"
    "FloorMgmtScheduledHours"
    "UnassignedVLHScheduleHours"
    "UnassignedFixedScheduleHours"
    "UnassignedFloorMgmtScheduleHours"
    "VLHNeededHours"
    "FloorMgmtNeededHours"
)

# --- Determine field and date ---
fieldname=""
target_date=""
for arg in "$arg2" "$arg3"; do
    [[ -z "$arg" ]] && continue
    normalized_arg=$(normalize_date "$arg")
    if [[ "$normalized_arg" =~ ^[0-9]{2}-[0-9]{2}-[0-9]{4}$ ]]; then
        target_date="$normalized_arg"
    else
        fieldname="$arg"
    fi
done

# --- Prepare fields to process ---
fields_to_process=()
if [ -n "$fieldname" ]; then
    fields_to_process=("$fieldname")
else
    fields_to_process=("${numeric_fields[@]}" "${time_fields[@]}")
fi

# --- Collect all dates ---
if [ -n "$target_date" ]; then
    date_array=("$target_date")
else
    mapfile -t date_array < <(jq -r '.[].Date' "$json_file")
fi

# --- Prepare output file if -p ---
if [ "$print_mode" = true ]; then
    read -rp "Enter Store Number: " store_number
    output_file="Results for ${store_number}"
    [ -n "$fieldname" ] && output_file+=" ${fieldname}"
    [ -n "$target_date" ] && output_file+=" ${target_date}"
    output_file+=".txt"
fi

# --- Start output collection ---
output="Reading file...\nTotaling data...\n"

# --- Main per-date loop ---
if [ "$summary_mode" = false ]; then
    for date in "${date_array[@]}"; do
        output+="---- Date: $date ----\n"
        for field in "${fields_to_process[@]}"; do
            if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
                total=$(jq -r --arg date "$date" --arg field "$field" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime | to_entries[] | .value[$field] | tonumber
                ' "$json_file" | jq -s 'add // 0')
                output+="$field: $(printf "%.2f" "$total")\n"
            elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
                total_minutes=0
                while IFS= read -r time_str; do
                    [[ -z "$time_str" || "$time_str" == "null" ]] && continue
                    mins=$(time_to_minutes "$time_str")
                    total_minutes=$((total_minutes + mins))
                done < <(jq -r --arg date "$date" --arg field "$field" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime | to_entries[] | .value[$field]
                ' "$json_file")
                total_time=$(minutes_to_time "$total_minutes")
                output+="$field: $total_time\n"
            else
                output+="$field: (unknown field)\n"
            fi
        done
        output+="\n"

        # --- Break mode ---
        if [ "$break_mode" = true ]; then
            read -rp "Press Enter to continue, or q to quit: " input < /dev/tty
            [[ "$input" =~ ^[Qq]$ ]] && exit 0
        fi
    done
fi

# --- GRAND TOTALS ---
# Only if summary mode, or print mode with no date
if [ "$summary_mode" = true ] || ([ "$print_mode" = true ] && [ -z "$target_date" ]); then
    output+="==== GRAND TOTALS ====\n"
    for field in "${fields_to_process[@]}"; do
        if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
            if [ -n "$target_date" ]; then
                total=$(jq -r --arg field "$field" --arg date "$target_date" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime | to_entries[] | .value[$field] | tonumber
                ' "$json_file" | jq -s 'add // 0')
            else
                total=$(jq -r --arg field "$field" '
                    .[] | .QuarterHourEndTime | to_entries[] | .value[$field] | tonumber
                ' "$json_file" | jq -s 'add // 0')
            fi
            output+="$field: $(printf "%.2f" "$total")\n"
        elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
            total_minutes=0
            if [ -n "$target_date" ]; then
                while IFS= read -r time_str; do
                    [[ -z "$time_str" || "$time_str" == "null" ]] && continue
                    mins=$(time_to_minutes "$time_str")
                    total_minutes=$((total_minutes + mins))
                done < <(jq -r --arg field "$field" --arg date "$target_date" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime | to_entries[] | .value[$field]
                ' "$json_file")
            else
                while IFS= read -r time_str; do
                    [[ -z "$time_str" || "$time_str" == "null" ]] && continue
                    mins=$(time_to_minutes "$time_str")
                    total_minutes=$((total_minutes + mins))
                done < <(jq -r --arg field "$field" '
                    .[] | .QuarterHourEndTime | to_entries[] | .value[$field]
                ' "$json_file")
            fi
            total_time=$(minutes_to_time "$total_minutes")
            output+="$field: $total_time\n"
        fi
    done
fi

# --- Print or save output ---
if [ "$print_mode" = true ]; then
    echo "File Created, press any key to continue..."
    echo -e "$output" > "$output_file"
    read -n1 -s
else
    echo -e "$output"
fi
