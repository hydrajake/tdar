#!/bin/bash
# tdar
# Version 2.8
# Updated 11/13/2025
# Totals numeric or time-based fields by date with break mode, summary mode, and grand totals
# Usage: tdar [-b] [-s] <file_name> [fieldname] [date]
# Written by J.Mock and M.Seifert
#

# --- Parse flags ---
break_mode=false
summary_mode=false

while [[ "$1" == -* ]]; do
    case "$1" in
        -b) break_mode=true ;;
        -s) summary_mode=true ;;
        *) echo "Unknown option $1"; exit 1 ;;
    esac
    shift
done

# --- Declarations ---
json_file="$1"
arg2="$2"
arg3="$3"
fieldname=""
target_date=""

if [ -z "$json_file" ]; then
    echo "Usage: $0 [-b] [-s] <json_file> [fieldname] [date]"
    echo "Examples:"
    echo "  $0 LIVE-DAR.json"
    echo "  $0 LIVE-DAR.json TotalSales"
    echo "  $0 LIVE-DAR.json 10-22-2025"
    echo "  $0 -b LIVE-DAR.json TotalSales 10-22-2025"
    echo "  $0 -s LIVE-DAR.json"
    exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is not installed. Please install it (e.g. sudo apt install jq)."
    exit 1
fi

# --- Optional cosmetic loading ---
echo "Reading file..."
sleep 1
echo "Totaling data..."
sleep 1

# --- Helpers ---
time_to_minutes() {
    local time_str="$1"
    [[ -z "$time_str" || "$time_str" == "null" ]] && echo 0 && return
    local hours="${time_str%%:*}"
    local minutes="${time_str##*:}"
    hours=$((10#$hours))
    minutes=$((10#$minutes))
    echo $((hours * 60 + minutes))
}

minutes_to_time() {
    local total_minutes="$1"
    local hours=$((total_minutes / 60))
    local minutes=$((total_minutes % 60))
    printf "%d:%02d" "$hours" "$minutes"
}

normalize_date() {
    local date_input="$1"
    echo "$date_input" | sed 's/[./]/-/g'
}

# --- Field lists ---
numeric_fields=(
    "TotalSales"
    "ActualPunchedDollars"
    "ActualTransactions"
    "ProjectedTransactions"
    "ActualSandwichCount"
    "ProjectedSandwichCount"
    "CrewActualPunchedDollars"
)

time_fields=(
    "ActualPunchedHours"
    "SalariedManagerScheduledHours"
    "TotalScheduleHours"
    "TotalNeededHours"
    "CrewLaborHours"
    "VLHScheduledHours"
    "FixedScheduledHours"
    "FloorMgmtScheduledHours"
    "UnassignedVLHScheduleHours"
    "UnassignedFixedScheduleHours"
    "UnassignedFloorMgmtScheduleHours"
    "VLHNeededHours"
    "FloorMgmtNeededHours"
)

# --- Determine which arg is date vs field ---
for arg in "$arg2" "$arg3"; do
    [[ -z "$arg" ]] && continue
    normalized_arg=$(normalize_date "$arg")
    if [[ "$normalized_arg" =~ ^[0-9]{2}-[0-9]{2}-[0-9]{4}$ ]]; then
        target_date="$normalized_arg"
    else
        fieldname="$arg"
    fi
done

# --- Select fields to process ---
if [ -n "$fieldname" ]; then
    fields_to_process=("$fieldname")
else
    fields_to_process=("${numeric_fields[@]}" "${time_fields[@]}")
fi

# --- Read dates into an array ---
if [ -n "$target_date" ]; then
    date_array=("$target_date")
else
    mapfile -t date_array < <(jq -r '.[].Date' "$json_file")
fi

# --- Main loop (only if not summary mode) ---
if [ "$summary_mode" = false ]; then
    for date in "${date_array[@]}"; do
        [[ -z "$date" ]] && continue
        echo "---- Date: $date ----"

        for field in "${fields_to_process[@]}"; do
            # Numeric field
            if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
                total=$(jq -r --arg date "$date" --arg field "$field" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime |
                    to_entries[] | .value[$field] | tonumber
                ' "$json_file" | jq -s 'add // 0')
                printf "%s: %.2f\n" "$field" "$total"

            # Time field
            elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
                total_minutes=0
                while IFS= read -r time_str; do
                    [[ -z "$time_str" || "$time_str" == "null" ]] && continue
                    mins=$(time_to_minutes "$time_str")
                    total_minutes=$((total_minutes + mins))
                done < <(jq -r --arg date "$date" --arg field "$field" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime |
                    to_entries[] | .value[$field]
                ' "$json_file")
                total_time=$(minutes_to_time "$total_minutes")
                echo "$field: $total_time"
            else
                echo "$field: (unknown field)"
            fi
        done

        # --- BREAK MODE PAUSE ---
        if [ "$break_mode" = true ]; then
            read -rp "Press Enter to continue, or q to quit: " input < /dev/tty
            if [[ "$input" =~ ^[Qq]$ ]]; then
                echo "Exiting break mode."
                exit 0
            fi
        fi

        echo ""
    done
fi

# --- GRAND TOTALS ---
# Only skip if a specific date was provided AND summary mode is not used
if [ "$summary_mode" = true ] || [ -z "$target_date" ]; then
    echo "==== GRAND TOTALS ===="
    for field in "${fields_to_process[@]}"; do
        if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
            if [ -n "$target_date" ]; then
                total=$(jq -r --arg field "$field" --arg date "$target_date" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime | to_entries[] | .value[$field] | tonumber
                ' "$json_file" | jq -s 'add // 0')
            else
                total=$(jq -r --arg field "$field" '
                    .[] | .QuarterHourEndTime | to_entries[] | .value[$field] | tonumber
                ' "$json_file" | jq -s 'add // 0')
            fi
            printf "%s: %.2f\n" "$field" "$total"

        elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
            total_minutes=0
            if [ -n "$target_date" ]; then
                while IFS= read -r time_str; do
                    [[ -z "$time_str" || "$time_str" == "null" ]] && continue
                    mins=$(time_to_minutes "$time_str")
                    total_minutes=$((total_minutes + mins))
                done < <(jq -r --arg field "$field" --arg date "$target_date" '
                    .[] | select(.Date == $date) | .QuarterHourEndTime | to_entries[] | .value[$field]
                ' "$json_file")
            else
                while IFS= read -r time_str; do
                    [[ -z "$time_str" || "$time_str" == "null" ]] && continue
                    mins=$(time_to_minutes "$time_str")
                    total_minutes=$((total_minutes + mins))
                done < <(jq -r --arg field "$field" '
                    .[] | .QuarterHourEndTime | to_entries[] | .value[$field]
                ' "$json_file")
            fi
            total_time=$(minutes_to_time "$total_minutes")
            echo "$field: $total_time"
        fi
    done
fi

