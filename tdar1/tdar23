#!/bin/bash
# tdar
# Version 3.0
# Updated 11/13/2025
# Totals numeric or time-based fields by date
# Usage: tdar [-b] [-s] [-p] <file_name> [field_name] [date]
# Written by J.Mock and M.Seifert

# -----------------------------
# Flags
# -----------------------------
breakmode=false
skipmode=false
printmode=false

while [[ "$1" == -* ]]; do
    case "$1" in
        -b) breakmode=true ;;
        -s) skipmode=true ;;
        -p) printmode=true ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
    shift
done

# -----------------------------
# Required argument: JSON file
# -----------------------------
json_file="$1"
if [ -z "$json_file" ]; then
    echo "Error: No JSON file specified."
    exit 1
fi
shift

if ! [ -f "$json_file" ]; then
    echo "Error: File '$json_file' not found."
    exit 1
fi

# -----------------------------
# Detect field and date
# -----------------------------
arg2="$1"
arg3="$2"

fieldname=""
target_date=""

normalize_date() {
    local d="$1"
    d="${d//./-}"
    d="${d//\//-}"
    if [[ "$d" =~ ^[0-9]{2}-[0-9]{2}-[0-9]{4}$ ]]; then
        echo "$d"
    else
        echo ""
    fi
}

# Field/date decision
if [[ -n "$arg2" ]]; then
    nd=$(normalize_date "$arg2")
    if [[ -n "$nd" ]]; then
        target_date="$nd"
    else
        fieldname="$arg2"
    fi
fi

if [[ -n "$arg3" ]]; then
    nd=$(normalize_date "$arg3")
    if [[ -n "$nd" ]]; then
        target_date="$nd"
    fi
fi

# -----------------------------
# Built-in fields
# -----------------------------
numeric_fields=(
    "TotalSales"
    "ActualPunchedDollars"
    "ActualTransactions"
    "ProjectedTransactions"
    "ActualSandwichCount"
    "ProjectedSandwichCount"
    "CrewActualPunchedDollars"
)

time_fields=(
    "ActualPunchedHours"
    "SalariedManagerScheduledHours"
    "TotalScheduleHours"
    "TotalNeededHours"
    "CrewLaborHours"
    "VLHScheduledHours"
    "FixedScheduledHours"
    "FloorMgmtScheduledHours"
    "UnassignedVLHScheduleHours"
    "UnassignedFixedScheduleHours"
    "UnassignedFloorMgmtScheduleHours"
    "VLHNeededHours"
    "FloorMgmtNeededHours"
)

# Determine which field(s) to process
fields_to_process=()
if [[ -n "$fieldname" ]]; then
    fields_to_process=("$fieldname")
else
    fields_to_process=("${numeric_fields[@]}" "${time_fields[@]}")
fi

# Determine dates to iterate
if [[ -n "$target_date" ]]; then
    dates="$target_date"
else
    dates=$(jq -r '.[].Date' "$json_file")
fi

# -----------------------------
# Helpers â€” time conversion
# -----------------------------
time_to_minutes() {
    local t="$1"
    [[ -z "$t" || "$t" == "null" ]] && echo 0 && return
    local h="${t%%:*}"
    local m="${t##*:}"
    echo $((10#$h * 60 + 10#$m))
}

minutes_to_time() {
    local total="$1"
    printf "%d:%02d" $((total/60)) $((total%60))
}

# -----------------------------
# Output buffer (for -p mode)
# -----------------------------
output="Reading file...\nTotaling data...\n\n"

# -----------------------------
# -b intro prompt
# -----------------------------
if $breakmode; then
    echo "Press Enter to begin..."
    read -r _ </dev/tty
fi

# -----------------------------
# MAIN LOGIC
# -----------------------------
process_date() {
    local date="$1"
    local block="---- Date: $date ----\n"

    for field in "${fields_to_process[@]}"; do
        # numeric fields
        if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
            total=$(jq -r --arg d "$date" --arg f "$field" '
                .[] | select(.Date == $d)
                | .QuarterHourEndTime
                | to_entries[]
                | .value[$f]
            ' "$json_file" | jq -s 'add // 0')
            total=$(printf "%.2f" "$total")
            block+="$field: $total\n"

        # time fields
        elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
            mins=0
            while IFS= read -r t; do
                val=$(time_to_minutes "$t")
                mins=$((mins + val))
            done < <(jq -r --arg d "$date" --arg f "$field" '
                .[] | select(.Date == $d)
                | .QuarterHourEndTime
                | to_entries[]
                | .value[$f]
            ' "$json_file")
            block+="$field: $(minutes_to_time "$mins")\n"

        else
            block+="$field: (unknown field)\n"
        fi
    done

    block+="\n"
    echo -e "$block"

    if $printmode; then
        output+="$block"
    fi

    if $breakmode; then
        echo -n "Press Enter to continue, or q to quit: "
        read -r key </dev/tty
        [[ "$key" == "q" ]] && exit 0
    fi
}

# -----------------------------
# Skip mode (-s): Only totals
# -----------------------------
do_grand_totals() {
    local block="==== GRAND TOTALS ====\n"

    for field in "${fields_to_process[@]}"; do
        if [[ " ${numeric_fields[*]} " == *" $field "* ]]; then
            total=$(jq -r --arg f "$field" '
                .[] | .QuarterHourEndTime | to_entries[] | .value[$f]
            ' "$json_file" | jq -s 'add // 0')
            total=$(printf "%.2f" "$total")
            block+="$field: $total\n"

        elif [[ " ${time_fields[*]} " == *" $field "* ]]; then
            mins=0
            while IFS= read -r t; do
                mins=$((mins + $(time_to_minutes "$t")))
            done < <(jq -r --arg f "$field" '
                .[] | .QuarterHourEndTime | to_entries[] | .value[$f]
            ' "$json_file")
            block+="$field: $(minutes_to_time "$mins")\n"
        fi
    done

    echo -e "$block"
    output+="$block"
}

# -----------------------------
# EXECUTION
# -----------------------------
if $skipmode && [[ -z "$target_date" ]]; then
    do_grand_totals
else
    while IFS= read -r d; do
        process_date "$d"
    done < <(printf "%s\n" "$dates")

    # No grand totals when a specific date is used
    if ! $skipmode && [[ -z "$target_date" ]]; then
        do_grand_totals
    fi
fi

# -----------------------------
# Print-to-file mode (-p)
# -----------------------------
if $printmode; then
    echo -n "Enter store number: "
    read store </dev/tty

    fname="Results for $store"
    [[ -n "$fieldname" ]] && fname+=" $fieldname"
    [[ -n "$target_date" ]] && fname+=" $target_date"
    fname+=".txt"

    echo -e "$output" > "$fname"
    echo "File created: $fname"
    echo "Press any key to continue..."
    read -r _ </dev/tty
fi
